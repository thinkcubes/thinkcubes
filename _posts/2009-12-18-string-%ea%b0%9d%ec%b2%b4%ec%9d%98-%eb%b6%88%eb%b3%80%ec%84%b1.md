---
ID: 533
post_title: String 객체의 불변성
author: ""
post_date: 2009-12-18 10:07:37
post_excerpt: ""
layout: post
permalink: 'http://52.78.225.187/2009/12/18/string-%ea%b0%9d%ec%b2%b4%ec%9d%98-%eb%b6%88%eb%b3%80%ec%84%b1/'
published: true
---
<P><STRONG># 불변성 (Immutability)</STRONG> : 해당 객체의 정보가 변하지 않는 것<BR><BR>불변(immutable) 클래스란 인스턴스가 변경되지 않는 클래스를 가리킨다. <BR><BR>자바 플랫폼에서 String, 박싱(boxing)된 원시 클래스, BigInteger, BigDecimal이<BR><BR>이러한 불변 클래스에 해당한다. <BR><BR>불변 클래스의 장점은 변하는(mutable) 클래스보다 설계, 구현 및 사용이 쉽다는 점이다. <BR><FONT color=#3a32c3><BR>String s = "0";<BR>f</FONT><FONT color=#3a32c3>or (int x = 1; x &lt; 10; x++) {<BR></FONT><FONT color=#3a32c3>&nbsp; &nbsp; s = s + x;<BR></FONT><FONT color=#3a32c3>}<BR></FONT><FONT color=#9a54ce><BR>&gt;&gt; s = "0123456789"<BR></FONT><BR>하지만 String 객체는 불변성을 가지기때문에 String 상수 10개 생성된다.<BR><BR>(0 01 012 0123 01234 ... 01234567890)<BR><BR>새로운 String을 만들 때 JVM에서는 그 상수를 "String 풀" 이라는 메모리 공간에 할당한다.<BR><BR>새로 생성된 String의 값은 변경할 수 없고,<BR><BR>대신 이후에 동일한 String 값이 들어오게 되는 경우에는<BR><BR>새로 생성하지 않고 기존에 있던 값에 참조를 걸게 된다.<BR><BR>그런데 가비지 컬렉터는 String 풀 영역에서는 동작하지 않는다.<BR><BR>즉, String을 생성하면 그 상수객체는 계속해서 메모리 영역을 차지하게 된다.<BR><BR>이러한 String 상수객체의 불변성 때문에 문자열 결합에서 성능이 저하될 수 있다.<BR><BR>// AS-IS :<BR><FONT color=#3a32c3>public String statement() {<BR></FONT><FONT color=#3a32c3>&nbsp; &nbsp; String result = "";<BR></FONT><FONT color=#3a32c3>&nbsp; &nbsp; for (int i = 0; i &lt; numItems(); i++) {<BR></FONT><FONT color=#3a32c3>&nbsp; &nbsp; &nbsp; &nbsp; result += lineForItem(i);<BR></FONT><FONT color=#3a32c3>&nbsp; &nbsp; }<BR></FONT><FONT color=#3a32c3>&nbsp; &nbsp; return result;<BR></FONT><FONT color=#3a32c3>}<BR></FONT><BR>// TO-BE :<BR><FONT color=#3a32c3>public String statement() {<BR></FONT><FONT color=#3a32c3>&nbsp; &nbsp; StringBuilder sb = new StringBuilder(numItems() * LINE_WIDTH);<BR></FONT><FONT color=#3a32c3>&nbsp; &nbsp; for (int i = 0; i &lt; numItems(); i++) {<BR></FONT><FONT color=#3a32c3>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sb.apped(lineForItem(i));<BR></FONT><FONT color=#3a32c3>&nbsp; &nbsp; }<BR></FONT><FONT color=#3a32c3>&nbsp; &nbsp; return b.toString();<BR></FONT><FONT color=#3a32c3>}<BR></FONT><BR>StringBuilder 의 크기를 정해주면 + 연산에 비해 85배 가량 빠르고,<BR><BR>default 크기로 사용해도 50 배 가량 빠르다. (머신에 따른 차이는 있음)<BR><FONT color=#3a32c3><BR>long startTime, endTime;<BR></FONT><FONT color=#3a32c3><BR>String s = new String();<BR></FONT><FONT color=#3a32c3>startTime = System.currentTimeMillis();<BR></FONT><FONT color=#3a32c3>for (int i = 0; i &lt; 100000; i++) {<BR></FONT><FONT color=#3a32c3>&nbsp; &nbsp; s += 'a';<BR></FONT><FONT color=#3a32c3>}<BR></FONT><FONT color=#3a32c3>endTime = System.currentTimeMillis();<BR></FONT><FONT color=#3a32c3>System.out.println("String : " + (end-start));<BR></FONT><FONT color=#3a32c3><BR>StringBuffer sb = new StringBuffer();<BR></FONT><FONT color=#3a32c3>start = System.currenTimeMillis();<BR></FONT><FONT color=#3a32c3>for (int i = 0; i &lt; 100000; i ++) {<BR></FONT><FONT color=#3a32c3>&nbsp; &nbsp; sb.append('a');<BR></FONT><FONT color=#3a32c3>}<BR></FONT><FONT color=#3a32c3>end = System.currentTimeMillis();<BR></FONT><FONT color=#3a32c3>System.out.println("SB : " + (end-start));<BR></FONT><FONT color=#7820b9><BR>&gt;&gt; String : 19297<BR></FONT><FONT color=#7820b9>&gt;&gt; SB : 0<BR><BR><BR></FONT><FONT color=#000000>출처 : Head First Java, Effective Java, 인터넷</FONT></P>